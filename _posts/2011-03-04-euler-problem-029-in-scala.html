--- 
permalink: /blog/euler-problem-029-in-scala.html
layout: post
title: Euler Problem 29 in Scala
published: true
category: programming
tags: 
- Project Euler
- Scala
- Tutorial
---
<p>Over the last couple of weeks, I've been slowly stepping through the wonderfully difficult problems at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. The problems found at Project Euler form a series  of progressively challenging mathematical questions, totalling 326 and  counting. You can expect questions about everything from counting to  prime factorization to sequence evaluation and beyond. For a great many of the exercises, there is an obvious brute force solution; but the fun is in getting as elegant and clever as you can possibly muster.</p>
<p>When I first heard of Project Euler, I signed up and dove right in. The question was not, "Do I want to do this?" or "Do I have the time to work through these?" I was in love with the idea right away. No, the question was, "What language should I tackle these problems with?" Normally, I am not hung up on language choice for any project. I have lost count of how many times I have parroted the old Dijkstra line that goes "Computer science is no more about computers than astronomy is about telescopes" or the similarly framed analogy that programming languages are to engineers as hammers are to carpenters. In short, I think of them as tools. And I would like to think that most problems can be solved by any number of languages. But I would be foolhardy to deny that I prefer some languages to others. My obsession with Python, for instance, is a tad unsettling. And going into a project which so thoroughly tests your mental limits, I wanted to work in a language that would ease the difficulties as much as possible. That's why I chose Scala.</p>
<p>Scala is a compelling mix of object orientation and functional programming, providing a flexibility and range of motion that is hard to find elsewhere. It is statically typed, and infers types pretty amazingly, from what I can tell. Initially, I was concerned that there  would be an untold amount of frustration from poor inferences, but the  compiler absolutely protects the coder. It has done so well for me, in  fact, that it has started to reinforce a sense about when to be explicit  and when to be implicit. And this is all well and good, but the functional aspects of the language are what truly intrigued me for this project. The comprehensions, the mapping capabilities, the high-order functions, the built-in pattern matching... they all apply well to purely mathematical pursuits.</p>
<p>And aside from all of that, I was/am still new to Scala and felt that this would be an excellent way to hone my skills and knowledge with the language. So I guess you could say that I came for the education but stayed for the tail recursion.</p>
<p><a href="http://projecteuler.net/index.php?section=problems&amp;id=29" title="Problem 29">Problem 029</a> is a particularly interesting way to demonstrate Scala's abilities to make life easier. It asks:</p>
<div class="problem_content">
<p style="padding-left: 30px;">Consider all integer combinations of <em>a</em><sup><em>b</em></sup> for 2 <img src="http://projecteuler.net/images/symbol_le.gif" border="0" height="12" alt="&amp;le;" style="vertical-align: middle;" width="10" /> <em>a</em> <img src="http://projecteuler.net/images/symbol_le.gif" border="0" height="12" alt="&amp;le;" style="vertical-align: middle;" width="10" /> 5 and 2 <img src="http://projecteuler.net/images/symbol_le.gif" border="0" height="12" alt="&amp;le;" style="vertical-align: middle;" width="10" /> <em>b</em> <img src="http://projecteuler.net/images/symbol_le.gif" border="0" height="12" alt="&amp;le;" style="vertical-align: middle;" width="10" /> 5:</p>
<blockquote style="padding-left: 30px;">2<sup>2</sup>=4, 2<sup>3</sup>=8, 2<sup>4</sup>=16, 2<sup>5</sup>=32<br /> 3<sup>2</sup>=9, 3<sup>3</sup>=27, 3<sup>4</sup>=81, 3<sup>5</sup>=243<br /> 4<sup>2</sup>=16, 4<sup>3</sup>=64, 4<sup>4</sup>=256, 4<sup>5</sup>=1024<br /> 5<sup>2</sup>=25, 5<sup>3</sup>=125, 5<sup>4</sup>=625, 5<sup>5</sup>=3125<br /></blockquote>
<p style="padding-left: 30px;">If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:</p>
<p style="text-align: center; padding-left: 30px;">4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125</p>
<p style="padding-left: 30px;">How many distinct terms are in the sequence generated by <em>a</em><sup><em>b</em></sup> for 2 <img src="http://projecteuler.net/images/symbol_le.gif" border="0" height="12" alt="&amp;le;" style="vertical-align: middle;" width="10" /> <em>a</em> <img src="http://projecteuler.net/images/symbol_le.gif" border="0" height="12" alt="&amp;le;" style="vertical-align: middle;" width="10" /> 100 and 2 <img src="http://projecteuler.net/images/symbol_le.gif" border="0" height="12" alt="&amp;le;" style="vertical-align: middle;" width="10" /> <em>b</em> <img src="http://projecteuler.net/images/symbol_le.gif" border="0" height="12" alt="&amp;le;" style="vertical-align: middle;" width="10" /> 100?</p>
<p>So what we're looking at here is a problem in which we will have to a) calculate some quite large numbers, up to 10^200 in fact,&nbsp; b) do these calculations over and over again, precisely 9801 times, and c) determine how many of these terms are unique. This is not the most puzzling or perplexing problem by any stretch of the imagination. But it does display Scala's power and flexibility. One of many possible solutions:</p><script src="https://gist.github.com/855478.js"></script><p>That's it. We defined a function <em>getDistinctCount(Int, Int) </em>which takes in lower and upper bounds (2 and 100 <em>&nbsp;</em>from the problem statement) and returns the number of distinct terms generated by our calculations. Scala provides a wonderful mapping function, which essentially takes a list of elements and individually maps each element by some specified function, returning the new list. In the code, we use <em>map</em> to map all <strong>b</strong> values to <strong>a^b</strong>, a mapping of <em>Int =&gt; Int</em>.</p>
<p>Also take note of the <em>flatMap</em> function, which instead of mapping all elements in the manner of <em>X =&gt; Y</em>, maps them in the manner of <em>X =&gt; Iterable[Y]</em> (<a href="http://richard.dallaway.com/in-praise-of-flatmap" title="In Praise of flatMap">This post</a> by Richard Dallaway is what finally revealed the workings of this function to me). We thus use the <em>flatMap</em> function to map each <strong>a </strong>value to <strong>each respective list</strong> produced by the previous <em>b mapping</em>, and then <strong>flatten</strong> this a-mapping into one list. We then reduce the list into only distinct elements and return the amount of elements in this final list, as seen by the <em>.distinct.size</em> portion of the code. And that integer value is our desired answer.</p>
<p>Basically, the one line of our <em>getDistinctCount</em> function maps each value of <strong>a</strong> to the <em>mapping</em> produced by mapping&nbsp; each value of <strong>b</strong> to <strong>a^b</strong>, and then returns how many unique terms are in that outer, master list. We could have written the entire script in just that one line, actually; the rest is fluff. In more imperative languages, this would have taken some nested for-loops and then some individual calls on the finished product to get our  final value. And for most languages, we would have had to explicitly specify everything, including return type and List types and so on. Here, Scala provided the capabilities to allow us to perform nested mapping in an intuitive manner, with absolutely no obstacles to a clean and simple solution. We just did some basic function calls and list comprehensions and called it a day. Pure fun.</p>
<p>And to handle the large numbers calculated by our exponents, we used the exceedingly handy BigInt type. <em>Thanks, Java.</em></p>
</div>
<p>But more importantly, thank you Project Euler for helping me to find such interesting and compelling ways to use Scala, one of my new joys in life.</p>
