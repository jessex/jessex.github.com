--- 
permalink: /blog/a-thought-experiment-in-programming-languages.html
layout: post
title: A Thought Experiment on Programming Languages
published: true
category: thought-experiment
tags: 
- Programming Languages
- Thought Experiment
---
<p>As is the case with everyone, I have a wide variety of interests. For instance, I am a huge basketball fan and have a taste for astronomy. At the intersection of these is of course <a href="http://en.wikipedia.org/wiki/Space_Jam" title="Greatest Jordan/Bugs Bunny Crossover of All Time">Space Jam</a>. I am also intrigued by the fields of language and of computation: at the intersection of these are, among other things, programming languages.</p>
<p>I have a great many thoughts on programming languages which are too numerous to enumerate here (namely because I do not care to at the moment). But I will note that I am extremely interested in language <em>creation</em>. As an extension of my own thoughts on the origin of natural language, I am fascinated by the process of making a brand new programming language. When <a href="http://code.google.com/p/go/" title="The Go Programming Language">Go</a> was announced back in 2009, I paid extremely close attention because it was the first time in my life as an engineer that I witnessed the birth of a potentially big new language. And one of the lessons that I have learned from observing Go is that people are hard to please.<!--more--></p>
<p>Chalk it up to inevitable growing pains, but seemingly all comments/writings that I heard/read on Go were split down the middle. Half of the people saw great potential and were intrigued by the idea of using it for a new project; half of the people saw fatal flaws and passed it off as a failed experiment. Personally, I think that Go has a fair deal of potential in a few different domains, but this is all auxiliary. <strong>The true point is that making a programming language is exceedingly difficult</strong>. Anyone who has tried to do so (and, really, anyone who has taken a course on compilers) will confirm this.</p>
<p>There are a great many choices that must be made when designing a new language. Syntax and semantics. Paradigms. Type systems (static, dynamic, weak, strong, safeties, oh my). Choosing structures and concepts to implement. Generics? Higher order functions? Compilation and interpretation. Memory allocation mechanisms. I/O, system calls, core libraries, on and on and on. And of course, after putting in months/years/lifetimes of work, there is always the chance that the language is announced and published and falls right down on its face because of some minute flaw that its designers never foresaw, or simply because no one really needs it. As an aside, the incomparable Steve Yegge once wrote a much-discussed post on <a href="http://steve-yegge.blogspot.com/2007/02/next-big-language.html" title="The Next Big Language"><em>The Next Big Language</em></a> which, in part, discussed his thoughts on what a new programming language requires in this day and age (see: 2007) to succeed.</p>
<p>So it seems that an undeniable fact of this difficult, multifaceted nature of programming language construction is that no language will please all types of users. All that a designer can/should do is try to make the best language that s/he can. Yet, lately I've been wondering about what languages can be expected from different segments of the programming world. <strong>That has lead to this thought experiment/question:</strong></p>
<p>In a large compound we place persons <em>A</em>, <em>B</em> and <em>C</em>. In this compound, the three will remain indefinitely, in their own work areas, to design their own respective programming languages. They will be provided with Internet access, a full library of books, assorted whiteboards, food, drink, everything. Just know that these three people will be perfectly sustained and given every resource needed to succeed. The only restriction is that they may have no contact to the outside world, or to each other, with regards to the language that each is designing.</p>
<p><em>Person A</em> is a long time engineering veteran. S/he received absolutely no formal Computer Science education. A is a self-made engineer who learned all s/he knows by tinkering with different languages and writing software. Don't ask <em>A</em> about NP-completeness unless you enjoy being met with vacant stares. In short, <em>Person A</em> is a full-on pragmatist whose only concern is accomplishing the current task at hand.</p>
<p><em>Person B</em> is a software engineer who graduated within the past, say, three to seven years from an esteemed Computer Science program. <em>B</em> is our control specimen: part academic, part practitioner, part scientist, part engineer. <em>B</em> has written software with a handful of languages and has been formally trained in general computer science, including in applicable topics such as compilers and linguistics. S/he is somewhere in between our two extremes.</p>
<p>And then we have perhaps the most interesting of characters, <em>Person C</em>. <em>C</em> has never seen or experienced any programming language and has never written a single line of code. <em>C</em> is an extremely exaggerated stereotype of the academic side of B: super classical Computer Science education and no "real world" experience. Essentially, <em>C</em> is pre-Lovelace, pre-programming, pre-software. Pre-everything. S/he is a master in theoretical computer science, though.</p>
<p><strong>And so the question is: what languages would persons <em>A</em>, <em>B</em> and <em>C</em> produce if left to their own devices and given an indefinite amount of time to create?</strong></p>
<p>Would <em>Person A</em> make a language like C (the language, not the hypothetical person)? Brutally efficient and minimalistic with basic, widespread syntactical standards and next to no frills? Would <em>Person C</em> re-make LISP? Wonderfully complex and innovative with remarkable elegance and dynamism in its structure? And just what the hell would <em>Person B</em> create? Would this mixed up amalgamation of idealism and pragmatism create a happy medium language that has what it takes to gain widespread acceptance? Or would it be a mixture of not-quite-fitting parts that ultimately falls flat? <em>It's hard to say</em>. But I would be extremely interested in seeing the results.</p>
<p>Still, I would like to think that all three of them would create something worthwhile. A new programming language is a major contribution to engineers, scientists, students, everyone. But it is such a risky investment of time, effort and resources with such a small possibility of "making it big." And yet, sometimes the most enormous of innovations comes from the most unlikely settings:</p>
<blockquote class="posterous_medium_quote">
<p>Over six years ago, in December 1989, I was looking for a "hobby"  programming project that would keep me occupied during the week around  Christmas. My office &hellip; would be closed, but I had a home computer, and  not much else on my hands. I decided to write an interpreter for the new  scripting language I had been thinking about lately: a descendant of  ABC that would appeal to Unix/C hackers.</p>
</blockquote>
<p>The man was Guido van Rossum and the language was Python. A hobby project to help pass the time with nothing more than a 1989-era PC and an idea became one of today's most widely used and heavily praised programming languages. That's innovation.</p>
